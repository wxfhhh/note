



[TOC]

# 继承与多态

## 继承

防止重复的代码

![image-20211013110209560](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013110209560.png)![image-20211013111135374](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013111135374.png)

### 定义一个父类  定义多个子类  

子类中虽然什么都没写，但还是会继承父类中的方法

### 继承中成员变量的访问特点

​        重名访问规则

1. 直接通过子类对象访问成员变量：

   等号左边是谁，就优先用谁，没有则向上找

   <!--等号左边 （看创建的对象）-->

2. 间接通过成员方法访问成员变量：

   该方法属于谁，就优先用谁

### 区分子类方法中重名的三种变量

![image-20211013113017617](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013113017617.png)

![image-20211013113120788](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013113120788.png)

### 继承中成员方法的访问特点![image-20211013113641943](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211013113641943.png)

### 继承中方法的覆盖重写

重写（Override）：在继承关系中，方法的名称一样，参数列表也一样。覆盖

重载（Overrode）：方法名称一样，参数列表不一样。

方法覆盖的特点：创建的是子类对象，则优先使用子类方法。

#### 注意事项

1.必须保证父子类之间方法的名称相同，参数列表也相同

@Override：写在方法前边，用来检测是不是有效的正确覆盖重写

<!--这个注释即使不写 满足了要求 也是正确的方法覆盖-->

2.子类方法的返回值必须小于等于父类方法的返回值范围

Object类是所有类的公共最高父类（祖先）

3.子类方法的权限必须大于等于父类方法的权限修饰符

<!--扩展：权限 public > protected >(default)>private-->

> (default) 不是关键字 而是什么都不写  如  int num(){}

#### 应用

推陈出新时  不能舍弃旧版本的内容 但又不想写重复的代码

![image-20211016210053338](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211016210053338.png)

可将旧版本视为父类  新版本为子类![image-20211016210002321](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211016210002321.png)

### 构造方法的访问特点

![image-20211023190018182](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211023190018182.png)

### super关键字

![image-20211023191538897](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211023191538897.png)

### this关键字

![image-20211023192355351](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211023192355351.png)

### java继承与多态的三种特点

![image-20211023195843306](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211023195843306.png)

## 抽象方法

概念：如果父类中的方法不确定如何通过{}方法体来实现，那么这就应该是一个抽象方法

> 求图形的面积的方法 动物吃东西的方法
>
> 无法确定是什么图形 是什么动物

![image-20211024193006464](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211024193006464.png)

### 如何使用抽象类和抽象方法

1. 不能直接创建new抽象类对象

2. 必须用一个子类来继承抽象父类

3. 子类必须覆盖重写抽象父类当中的所有抽象方法方法

   > 覆盖重写：子类去掉父类方法的abstract关键字 再加上大括号和方法体

4. 创建子类对象进行使用

## 接口

### 定义的格式

![image-20211024203642358](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211024203642358.png)

### 接口的抽象方法

在任何版本的Java中 接口都能定义抽象方法

> 格式： public abstract 返回值类型 方法名称 ( ) ;

注意事项：

1. 接口当中的抽象方法，必须是两个固定的关键字：public abstact
2. 这两个关键字修饰符可以选择性的省略（刚学不建议）
3. 方法的三要素可以随机选择

![image-20211025192902583](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211025192902583.png)

### 接口的使用步骤

1.接口不能直接使用，必须要创建一个实现类来“实现”该接口  格式：  

public class 实现类名称 implement 接口 {

}

2.实现类必须覆盖重写该接口中的所有抽象方法

实现：去掉abstract 关键字 加上方法体大括号

3.创建实现类的对象  进行使用

注意事项： 如果这个抽象类中没有覆盖重写接口中所有的抽象方法，那么这个实现类自己必须是抽象类

### 接口的默认方法使用

接口当中的默认方法，解决了接口升级的问题

1. 接口当中的默认方法，可以通过实现类直接调用

2. 接口当中的默认方法，也可以被接口实现类进行覆盖重写

3. （接口的默认方法可以拼接函数模型 以后讲）

   调用接口中的静态方法，利用实现类来进行方法的调用。

### 接口当中静态方法的使用

<font color=red>**注意事项**</font>:不能通过接口的实现类对象来调用接口中的静态方法

正确方法：通过接口名称直接调用静态方法

格式：接口名称.静态方法名称(参数);

### 接口中私有方法的使用

问题描述：

我们需要抽取一个公有方法，用来解决两个默认方法之间的重复代码的问题，但是这个共有方法不应该让实现类使用，而应该是私有的

解决方案：使用私有方法

普通私有方法：解决多个默认方法之间代码重复的问题

private 返回值类型 方法名 （参数）{

  				方法体;

}

静态私有方法：解决多个静态方法之间代码重复的问题

private static 返回值类型 方法名 （参数）{

​						方法体;

}

### 接口中的变量（名称完全<font color=red>大写</font>）

![image-20211025205729294](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211025205729294.png)

3.![image-20211026190810136](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211026190810136.png)

运用时直接通过接口名称.变量名;

### 小结

```java
/*在Java 9+版本中，接口的内容可以有:
1．成员变量其实是常量，格式:
[public] [static] [final]数据类型 常量名称=数据值;注意:
常量必须进行赋值，而且一旦赋值不能改变。常量名称完全大写，用下划线进行分隔。
2．接口中最重要的就是抽象方法，格式:
[public] [abstract] 返回值类型 方法名称(参数列表);
注意:实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。
3．从Java 8开始，接口里允许定义默认方法，格式:
[public] default 返回值类型 方法名称(参数列表){方法体}注意:默认方法也可以被覆盖重写
4．从Java 8开始，接口里允许定义静态方法，格式:
[public] static返回值类型方法名称(参数列表){方法体}
注意:应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法
5．从Java 9开始，接口里允许定义私有方法，格式:
普通私有方法: private 返回值类型 方法名称(参数列表){方法体}
静态私有方法: private static返回值类型 方法名称(参数列表){方法体}注意: private的方法只有接口自己才能调用，不能被实现类或别人使用。
*/
```

### 继承父类并实现多个接口

1．接口是没有静态代码块或者构造方法的。
2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式:
public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceB {
    //覆盖重写所有抽象方法
}
3．如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写<font color=red>一次</font>即可。
4．如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个**抽象类**。
5．如果实现类锁实现的多个接口当中，存在重复的默认方法，那么**实现类一定要对冲突的默认方法进行覆盖重写。**
6．一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，<font color=red >优先用父类当中的方法</font>。

### 接口之间的多继承

1．类与类之间是单继承的。直接父类只有一个。
2．类与接口之间是多实现的。一个类可以实现多个接口。

3．接口与接口之间是多继承的。
注意事项:
1.多个父接口当中的<font color=red>抽象方法</font>如果重复，没关系。
2.多个父接口当中的<font color=red>默认方法</font>如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。

## 多态

![image-20211026200927583](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211026200927583.png)

### 多态访问成员变量的两种方式

1. 看等号左边是谁，优先用谁，没有则向上找。
2. 看该方法属于谁，优先用谁，没有则向上找。（与之前继承的规则一样）

![image-20211027192118084](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211027192118084.png)

> 第二点的访问成员方法的规则 用练习来实现

### 多态访问成员方法的规则

**编译看左边 运行看右边**

> 编译看左边 运行也看左边

### 使用多态的好处![image-20211030145749704](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211030145749704.png)

好处：无论new的时候换成哪个子类对象，等号左边调用的方法都不会变化。

> 让代码更加灵活



### 使用多态的弊端

不能使用子类特有的方法

### 对象的向上转型

其实就是多态的写法

> 格式： 父类名称 对象名 =new 子类名称;

含义：右侧创建一个子类对象，将它当成父类来看待

```java
 Animal cat=new Cat;
//创建一只猫，把它当作动物来看待 没毛病！
```

注意事项：向上转型一定是<font color=red>安全的</font>  从小范围转型到大范围

<!--类似于自动类型转换   double num =100; int--》double -->

### 对象的向下转型

其实就是一个【还原】动作

格式： 子类对象 对象名=(子类名称)父类对象;

含义：将父类对象，还原为本来的子类对象。

![image-20211030153600629](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211030153600629.png)

```java
Animal animal=new Cat();// 本来就是猫 想向上转型为动物
Cat cat =(Cat) animal;//本来是猫 已经被当成了动物 现在要还原为本来的猫
注意事项：
   1.必须保证对象本来创建的时候，就是猫 才能向下转型为猫。
   2.如果对象创建的时候就不是猫，现在非要向下转型为猫，就会报错。
    //有一点抽象 用代码来实现 CalssCastException

```

![image-20211030153728348](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211030153728348.png)

<font color=red>类似于</font>

**强制类型转换** 

```java
 int num=(int) 10.0;
// int num1=(int)10.5;报错 会发生精度损失 
```

### 使用接口USB实例	![image-20211030160635019](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211030160635019.png)

### instanceof

instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。

> 对象的向下转型中用到

## final关键字

final表示最终的，不可改变的。

### 1.用来修饰一个类

格式： public final class 类名称（）{

}

含义：当前这个类不能拥有任何子类。（太监类）

注意：一个类如果是final的，那么其中所有的成员方法都不能进行覆盖重写（因为没儿子）

### 2.用来修饰一个方法

当final关键字用来修饰一个方法的时候，这个方法也就是最终方法，也就是不能覆盖重写。

格式：final 返回值类型 方法名称（参数列表）{

//方法体

}

注意事项：对于类和方法来说，obstract关键字和final关键字不能同时使用，因为矛盾。

### 3.用来修饰局部变量

一旦用final来修饰变量 就不可改变

格式：public static final 数据类型 数据名称=数据值;

​     对于基本类型来说，不可改变的是变量当中的数据

​    对于引用类型来说，不可改变的是变量当中的地址值

### 4.用来修饰成员变量

1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。

### 四种权限修饰符

![image-20211102210341606](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211102210341606.png)

## 内部类

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。

内部类的命名格式： 外部类 $ 内部类

### 分类

1. 成员内部类
2. 局部内部类（包含匿名内部类）

成员内部类的定义格式：

```java
修饰符 class 外部类名称{
    修饰符 class 内部类名称;
    //...

}
注意：内用外 随意访问 外用内 需要内部类对象
```

show in explorer  在文件夹中打开

### 如何使用成员内部类

1. 间接使用，在外部类的方法中，使用内部类，然后main只是调用外部类的方法。

   通过创建外部类对象 调用外部类的方法 来间接使用内部类

2. 直接使用 直接创建内部类的对象 

   常规格式： 类名称 对象名=new 类名称();

   【外部类名称.内部类名称 对象名=new 外部类名称().new 内部类名称();】

### 如何访问重名的外部类

内部类中：

1. 访问本类方法中的变量:直接写名称
2. 访问本类中的成员变量：this.变量名称
3. 访问外部类的成员变量：外部类名称.this.变量名称

### 局部内部类

概念：如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

“局部”：只有<font color=red>当前所属的方法</font>才能使用它，除了这个方法外面就不能使用了

```java
使用格式：
    修饰符 class 外部类名称{
        修饰符 返回值类型 外部类方法名称(参数列表){
            class 局部内部类名称{
                //...
            }
        }
        
    }
```

注意事项：局部内部类，要想访问所在方法的局部变量，那么这个局部变量就必须是有效的【final】

但从Java8开始，只要局部变量事实不变，那么final关键字可以省略

#### 如何使用局部内部类

在当前创建的方法中创建一个内部类对象 再通过main方法调用外部类的成员方法

### 类的权限修饰符

![](https://img10.360buyimg.com/ddimg/jfs/t1/218493/7/3229/189444/6185277aEe6467144/6b7684bcb2a1e8af.png)

### 匿名内部类

使用情况：如果接口的实现类（或父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。

![](https://img13.360buyimg.com/ddimg/jfs/t1/199199/28/16253/49710/61866768Eabd548ed/22be206ea1733ea3.png)

匿名内部类的定义格式：

```java
接口名称 对象名=new 接口名称(){
    //覆盖重写所有的抽象方法
};
//不要忘记分号
```

![](https://img13.360buyimg.com/ddimg/jfs/t1/222529/24/1760/183213/6187a1b5E4cd7419c/a0489eaad95a6640.png)

![](https://img11.360buyimg.com/ddimg/jfs/t1/199075/22/16277/314380/618672deE6d6af272/0ea367a8737ae7ca.png)

匿名内部类和匿名对象不一样！！！！

![](https://img10.360buyimg.com/ddimg/jfs/t1/219924/28/3462/305202/618674e5E2f9b202c/dafe3cadcf180c59.png)

